/*
    straussR is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    straussR is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with straussR.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_straussR_mixed_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_straussR_mixed");
    reader.add_event(1, 1, "include", "/chunks/densities.stan");
    reader.add_event(1, 0, "start", "/chunks/densities.stan");
    reader.add_event(153, 152, "end", "/chunks/densities.stan");
    reader.add_event(153, 2, "restart", "model_straussR_mixed");
    reader.add_event(153, 2, "include", "/chunks/beta_priors.stan");
    reader.add_event(153, 0, "start", "/chunks/beta_priors.stan");
    reader.add_event(317, 164, "end", "/chunks/beta_priors.stan");
    reader.add_event(317, 3, "restart", "model_straussR_mixed");
    reader.add_event(317, 3, "include", "/chunks/parameters_array.stan");
    reader.add_event(317, 0, "start", "/chunks/parameters_array.stan");
    reader.add_event(393, 76, "end", "/chunks/parameters_array.stan");
    reader.add_event(393, 4, "restart", "model_straussR_mixed");
    reader.add_event(393, 4, "include", "/chunks/likelihood.stan");
    reader.add_event(393, 0, "start", "/chunks/likelihood.stan");
    reader.add_event(496, 103, "end", "/chunks/likelihood.stan");
    reader.add_event(496, 5, "restart", "model_straussR_mixed");
    reader.add_event(496, 5, "include", "/chunks/distributions.stan");
    reader.add_event(496, 0, "start", "/chunks/distributions.stan");
    reader.add_event(660, 164, "end", "/chunks/distributions.stan");
    reader.add_event(660, 6, "restart", "model_straussR_mixed");
    reader.add_event(770, 116, "end", "model_straussR_mixed");
    return reader;
}

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
fnormal_lpdf(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 12;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_sum_exp(normal_log(y,mu,sigma),normal_log(y,-(mu),sigma)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
fnormal_lpdf(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) {
    return fnormal_lpdf<false>(y,mu,sigma, pstream__);
}


struct fnormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) const {
        return fnormal_lpdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
fnormal_cdf(const T0__& y,
                const T1__& mu,
                const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 17;
        return stan::math::promote_scalar<fun_return_scalar_t__>(((normal_cdf(y,mu,sigma) + normal_cdf(y,-(mu),sigma)) - 1));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct fnormal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                const T1__& mu,
                const T2__& sigma, std::ostream* pstream__) const {
        return fnormal_cdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
fnormal_ccdf(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 21;
        return stan::math::promote_scalar<fun_return_scalar_t__>(((2 - normal_cdf(y,mu,sigma)) - normal_cdf(y,-(mu),sigma)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct fnormal_ccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) const {
        return fnormal_ccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
fnormal_lcdf(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 25;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log(((normal_cdf(y,mu,sigma) + normal_cdf(y,-(mu),sigma)) - 1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct fnormal_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                 const T1__& mu,
                 const T2__& sigma, std::ostream* pstream__) const {
        return fnormal_lcdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
fnormal_lccdf(const T0__& y,
                  const T1__& mu,
                  const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 30;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log(((2 - normal_cdf(y,mu,sigma)) - normal_cdf(y,-(mu),sigma))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct fnormal_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                  const T1__& mu,
                  const T2__& sigma, std::ostream* pstream__) const {
        return fnormal_lccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
fnormal_rng(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 34;
        return stan::math::promote_scalar<fun_return_scalar_t__>(fabs(normal_rng(mu,sigma, base_rng__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct fnormal_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return fnormal_rng(mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
lower_fnormal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 50;
        return stan::math::promote_scalar<fun_return_scalar_t__>((fnormal_lpdf(y,mu,1, pstream__) - fnormal_lccdf(lower,mu,1, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
lower_fnormal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower, std::ostream* pstream__) {
    return lower_fnormal_lpdf<false>(y,mu,sigma,lower, pstream__);
}


struct lower_fnormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower, std::ostream* pstream__) const {
        return lower_fnormal_lpdf(y, mu, sigma, lower, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
upper_fnormal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& upper, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 54;
        return stan::math::promote_scalar<fun_return_scalar_t__>((fnormal_lpdf(y,mu,1, pstream__) - fnormal_lcdf(upper,mu,1, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
upper_fnormal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& upper, std::ostream* pstream__) {
    return upper_fnormal_lpdf<false>(y,mu,sigma,upper, pstream__);
}


struct upper_fnormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& upper, std::ostream* pstream__) const {
        return upper_fnormal_lpdf(y, mu, sigma, upper, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
inner_fnormal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower,
                       const T4__& upper, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 58;
        return stan::math::promote_scalar<fun_return_scalar_t__>((fnormal_lpdf(y,mu,1, pstream__) - log((fnormal_cdf(upper,mu,sigma, pstream__) - fnormal_cdf(lower,mu,sigma, pstream__)))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
inner_fnormal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower,
                       const T4__& upper, std::ostream* pstream__) {
    return inner_fnormal_lpdf<false>(y,mu,sigma,lower,upper, pstream__);
}


struct inner_fnormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower,
                       const T4__& upper, std::ostream* pstream__) const {
        return inner_fnormal_lpdf(y, mu, sigma, lower, upper, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
double_fnormal_lpdf(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma,
                        const T3__& lower,
                        const T4__& upper, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 64;
        return stan::math::promote_scalar<fun_return_scalar_t__>((fnormal_lpdf(y,mu,1, pstream__) - log((fnormal_cdf(upper,mu,sigma, pstream__) + fnormal_ccdf(lower,mu,sigma, pstream__)))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
double_fnormal_lpdf(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma,
                        const T3__& lower,
                        const T4__& upper, std::ostream* pstream__) {
    return double_fnormal_lpdf<false>(y,mu,sigma,lower,upper, pstream__);
}


struct double_fnormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma,
                        const T3__& lower,
                        const T4__& upper, std::ostream* pstream__) const {
        return double_fnormal_lpdf(y, mu, sigma, lower, upper, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
lower_normal_lpdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& lower, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 69;
        return stan::math::promote_scalar<fun_return_scalar_t__>((normal_log(y,mu,1) - normal_ccdf_log(lower,mu,1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
lower_normal_lpdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& lower, std::ostream* pstream__) {
    return lower_normal_lpdf<false>(y,mu,sigma,lower, pstream__);
}


struct lower_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& lower, std::ostream* pstream__) const {
        return lower_normal_lpdf(y, mu, sigma, lower, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
upper_normal_lpdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& upper, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 73;
        return stan::math::promote_scalar<fun_return_scalar_t__>((normal_log(y,mu,1) - normal_cdf_log(upper,mu,1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
upper_normal_lpdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& upper, std::ostream* pstream__) {
    return upper_normal_lpdf<false>(y,mu,sigma,upper, pstream__);
}


struct upper_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& upper, std::ostream* pstream__) const {
        return upper_normal_lpdf(y, mu, sigma, upper, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
inner_normal_lpdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& lower,
                      const T4__& upper, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 77;
        return stan::math::promote_scalar<fun_return_scalar_t__>((normal_log(y,mu,1) - log((normal_cdf(upper,mu,sigma) - normal_cdf(lower,mu,sigma)))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
inner_normal_lpdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& lower,
                      const T4__& upper, std::ostream* pstream__) {
    return inner_normal_lpdf<false>(y,mu,sigma,lower,upper, pstream__);
}


struct inner_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma,
                      const T3__& lower,
                      const T4__& upper, std::ostream* pstream__) const {
        return inner_normal_lpdf(y, mu, sigma, lower, upper, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
double_normal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower,
                       const T4__& upper, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 83;
        return stan::math::promote_scalar<fun_return_scalar_t__>((normal_log(y,mu,1) - log((normal_cdf(upper,mu,sigma) + normal_cdf(-(lower),-(mu),sigma)))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
double_normal_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower,
                       const T4__& upper, std::ostream* pstream__) {
    return double_normal_lpdf<false>(y,mu,sigma,lower,upper, pstream__);
}


struct double_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma,
                       const T3__& lower,
                       const T4__& upper, std::ostream* pstream__) const {
        return double_normal_lpdf(y, mu, sigma, lower, upper, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_fnormal_lower_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 100;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,lower_fnormal_lpdf(y,mu,1,lower, pstream__),fnormal_lpdf(y,mu,1, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_fnormal_lower_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& p, std::ostream* pstream__) {
    return mix_fnormal_lower_lpdf<false>(y,mu,lower,p, pstream__);
}


struct mix_fnormal_lower_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& p, std::ostream* pstream__) const {
        return mix_fnormal_lower_lpdf(y, mu, lower, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_fnormal_upper_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& upper,
                           const T3__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 105;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,upper_fnormal_lpdf(y,mu,1,upper, pstream__),fnormal_lpdf(y,mu,1, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_fnormal_upper_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& upper,
                           const T3__& p, std::ostream* pstream__) {
    return mix_fnormal_upper_lpdf<false>(y,mu,upper,p, pstream__);
}


struct mix_fnormal_upper_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                           const T1__& mu,
                           const T2__& upper,
                           const T3__& p, std::ostream* pstream__) const {
        return mix_fnormal_upper_lpdf(y, mu, upper, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_fnormal_double_lpdf(const T0__& y,
                            const T1__& mu,
                            const T2__& lower,
                            const T3__& upper,
                            const T4__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 110;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,double_normal_lpdf(y,mu,1,lower,upper, pstream__),fnormal_lpdf(y,mu,1, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_fnormal_double_lpdf(const T0__& y,
                            const T1__& mu,
                            const T2__& lower,
                            const T3__& upper,
                            const T4__& p, std::ostream* pstream__) {
    return mix_fnormal_double_lpdf<false>(y,mu,lower,upper,p, pstream__);
}


struct mix_fnormal_double_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                            const T1__& mu,
                            const T2__& lower,
                            const T3__& upper,
                            const T4__& p, std::ostream* pstream__) const {
        return mix_fnormal_double_lpdf(y, mu, lower, upper, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_fnormal_inner_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& upper,
                           const T4__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 115;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,inner_fnormal_lpdf(y,mu,1,lower,upper, pstream__),fnormal_lpdf(y,mu,1, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_fnormal_inner_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& upper,
                           const T4__& p, std::ostream* pstream__) {
    return mix_fnormal_inner_lpdf<false>(y,mu,lower,upper,p, pstream__);
}


struct mix_fnormal_inner_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& upper,
                           const T4__& p, std::ostream* pstream__) const {
        return mix_fnormal_inner_lpdf(y, mu, lower, upper, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_normal_lower_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& lower,
                          const T3__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 121;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,lower_fnormal_lpdf(y,mu,1,lower, pstream__),normal_log(y,mu,1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_normal_lower_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& lower,
                          const T3__& p, std::ostream* pstream__) {
    return mix_normal_lower_lpdf<false>(y,mu,lower,p, pstream__);
}


struct mix_normal_lower_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                          const T1__& mu,
                          const T2__& lower,
                          const T3__& p, std::ostream* pstream__) const {
        return mix_normal_lower_lpdf(y, mu, lower, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_normal_upper_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& upper,
                          const T3__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 126;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,upper_normal_lpdf(y,mu,1,upper, pstream__),normal_log(y,mu,1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
mix_normal_upper_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& upper,
                          const T3__& p, std::ostream* pstream__) {
    return mix_normal_upper_lpdf<false>(y,mu,upper,p, pstream__);
}


struct mix_normal_upper_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                          const T1__& mu,
                          const T2__& upper,
                          const T3__& p, std::ostream* pstream__) const {
        return mix_normal_upper_lpdf(y, mu, upper, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_normal_double_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& upper,
                           const T4__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 131;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,double_normal_lpdf(y,mu,1,lower,upper, pstream__),normal_log(y,mu,1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_normal_double_lpdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& upper,
                           const T4__& p, std::ostream* pstream__) {
    return mix_normal_double_lpdf<false>(y,mu,lower,upper,p, pstream__);
}


struct mix_normal_double_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                           const T1__& mu,
                           const T2__& lower,
                           const T3__& upper,
                           const T4__& p, std::ostream* pstream__) const {
        return mix_normal_double_lpdf(y, mu, lower, upper, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_normal_inner_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& lower,
                          const T3__& upper,
                          const T4__& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 136;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_mix(p,inner_normal_lpdf(y,mu,1,lower,upper, pstream__),normal_log(y,mu,1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
mix_normal_inner_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& lower,
                          const T3__& upper,
                          const T4__& p, std::ostream* pstream__) {
    return mix_normal_inner_lpdf<false>(y,mu,lower,upper,p, pstream__);
}


struct mix_normal_inner_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                          const T1__& mu,
                          const T2__& lower,
                          const T3__& upper,
                          const T4__& p, std::ostream* pstream__) const {
        return mix_normal_inner_lpdf(y, mu, lower, upper, p, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
inverse_gaussian_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& lambda, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 151;
        return stan::math::promote_scalar<fun_return_scalar_t__>(((0.5 * (((log(lambda) - log(2)) - log(stan::math::pi())) - (3 * log(y)))) - ((lambda * pow((y - mu),2)) / ((2 * pow(mu,2)) * y))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
inverse_gaussian_lpdf(const T0__& y,
                          const T1__& mu,
                          const T2__& lambda, std::ostream* pstream__) {
    return inverse_gaussian_lpdf<false>(y,mu,lambda, pstream__);
}


struct inverse_gaussian_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                          const T1__& mu,
                          const T2__& lambda, std::ostream* pstream__) const {
        return inverse_gaussian_lpdf(y, mu, lambda, pstream__);
    }
};

template <bool propto, typename T0__, typename T4__>
typename boost::math::tools::promote_args<T0__, T4__>::type
unbounded_lpdf(const std::vector<T0__>& beta,
                   const int& Q,
                   const std::vector<int>& no,
                   const std::vector<std::vector<int> >& prior_types,
                   const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T4__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 156;
        int index(0);
        (void) index;  // dummy to suppress unused var warning

        stan::math::fill(index, std::numeric_limits<int>::min());
        stan::math::assign(index,1);
        current_statement_begin__ = 157;
        fun_scalar_t__ lpdf;
        (void) lpdf;  // dummy to suppress unused var warning

        stan::math::initialize(lpdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(lpdf,DUMMY_VAR__);
        stan::math::assign(lpdf,0);


        current_statement_begin__ = 159;
        for (int q = 1; q <= Q; ++q) {

            current_statement_begin__ = 160;
            if (as_bool(logical_gt(get_base1(no,q,"no",1),0))) {

                current_statement_begin__ = 161;
                for (int p = 1; p <= get_base1(no,q,"no",1); ++p) {

                    current_statement_begin__ = 162;
                    if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),100))) {

                        current_statement_begin__ = 164;
                        stan::math::assign(lpdf, (lpdf + normal_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),101))) {

                        current_statement_begin__ = 169;
                        stan::math::assign(lpdf, (lpdf + exp_mod_normal_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),3,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),102))) {

                        current_statement_begin__ = 175;
                        stan::math::assign(lpdf, (lpdf + skew_normal_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),3,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),103))) {

                        current_statement_begin__ = 181;
                        stan::math::assign(lpdf, (lpdf + student_t_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),3,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),104))) {

                        current_statement_begin__ = 187;
                        stan::math::assign(lpdf, (lpdf + cauchy_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),105))) {

                        current_statement_begin__ = 192;
                        stan::math::assign(lpdf, (lpdf + double_exponential_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),106))) {

                        current_statement_begin__ = 197;
                        stan::math::assign(lpdf, (lpdf + logistic_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),107))) {

                        current_statement_begin__ = 202;
                        stan::math::assign(lpdf, (lpdf + gumbel_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    }
                }
                current_statement_begin__ = 208;
                stan::math::assign(index, (index + 1));
            }
        }
        current_statement_begin__ = 214;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lpdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T4__>
typename boost::math::tools::promote_args<T0__, T4__>::type
unbounded_lpdf(const std::vector<T0__>& beta,
                   const int& Q,
                   const std::vector<int>& no,
                   const std::vector<std::vector<int> >& prior_types,
                   const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) {
    return unbounded_lpdf<false>(beta,Q,no,prior_types,prior, pstream__);
}


struct unbounded_lpdf_functor__ {
    template <bool propto, typename T0__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T4__>::type
    operator()(const std::vector<T0__>& beta,
                   const int& Q,
                   const std::vector<int>& no,
                   const std::vector<std::vector<int> >& prior_types,
                   const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) const {
        return unbounded_lpdf(beta, Q, no, prior_types, prior, pstream__);
    }
};

template <bool propto, typename T0__, typename T4__>
typename boost::math::tools::promote_args<T0__, T4__>::type
positive_lpdf(const std::vector<T0__>& beta,
                  const int& Q,
                  const std::vector<int>& no,
                  const std::vector<std::vector<int> >& prior_types,
                  const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T4__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 220;
        int index(0);
        (void) index;  // dummy to suppress unused var warning

        stan::math::fill(index, std::numeric_limits<int>::min());
        stan::math::assign(index,1);
        current_statement_begin__ = 221;
        fun_scalar_t__ lpdf;
        (void) lpdf;  // dummy to suppress unused var warning

        stan::math::initialize(lpdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(lpdf,DUMMY_VAR__);
        stan::math::assign(lpdf,0);


        current_statement_begin__ = 223;
        for (int q = 1; q <= Q; ++q) {

            current_statement_begin__ = 224;
            if (as_bool(logical_gt(get_base1(no,q,"no",1),0))) {

                current_statement_begin__ = 225;
                for (int p = 1; p <= get_base1(no,q,"no",1); ++p) {

                    current_statement_begin__ = 226;
                    if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),200))) {

                        current_statement_begin__ = 228;
                        stan::math::assign(lpdf, (lpdf + lognormal_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),201))) {

                        current_statement_begin__ = 233;
                        stan::math::assign(lpdf, (lpdf + chi_square_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),202))) {

                        current_statement_begin__ = 237;
                        stan::math::assign(lpdf, (lpdf + inv_chi_square_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),203))) {

                        current_statement_begin__ = 241;
                        stan::math::assign(lpdf, (lpdf + scaled_inv_chi_square_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),204))) {

                        current_statement_begin__ = 246;
                        stan::math::assign(lpdf, (lpdf + exponential_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),205))) {

                        current_statement_begin__ = 250;
                        stan::math::assign(lpdf, (lpdf + gamma_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),206))) {

                        current_statement_begin__ = 255;
                        stan::math::assign(lpdf, (lpdf + inv_gamma_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),207))) {

                        current_statement_begin__ = 260;
                        stan::math::assign(lpdf, (lpdf + weibull_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),208))) {

                        current_statement_begin__ = 265;
                        stan::math::assign(lpdf, (lpdf + frechet_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),300))) {

                        current_statement_begin__ = 270;
                        stan::math::assign(lpdf, (lpdf + rayleigh_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),301))) {

                        current_statement_begin__ = 274;
                        stan::math::assign(lpdf, (lpdf + wiener_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),3,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),4,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),400))) {

                        current_statement_begin__ = 281;
                        stan::math::assign(lpdf, (lpdf + pareto_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    } else if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),401))) {

                        current_statement_begin__ = 286;
                        stan::math::assign(lpdf, (lpdf + pareto_type_2_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),3,"prior",2),q,"prior",3))));
                    }
                }
                current_statement_begin__ = 291;
                stan::math::assign(index, (index + 1));
            }
        }
        current_statement_begin__ = 295;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lpdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T4__>
typename boost::math::tools::promote_args<T0__, T4__>::type
positive_lpdf(const std::vector<T0__>& beta,
                  const int& Q,
                  const std::vector<int>& no,
                  const std::vector<std::vector<int> >& prior_types,
                  const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) {
    return positive_lpdf<false>(beta,Q,no,prior_types,prior, pstream__);
}


struct positive_lpdf_functor__ {
    template <bool propto, typename T0__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T4__>::type
    operator()(const std::vector<T0__>& beta,
                  const int& Q,
                  const std::vector<int>& no,
                  const std::vector<std::vector<int> >& prior_types,
                  const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) const {
        return positive_lpdf(beta, Q, no, prior_types, prior, pstream__);
    }
};

template <bool propto, typename T0__, typename T4__>
typename boost::math::tools::promote_args<T0__, T4__>::type
unit_lpdf(const std::vector<T0__>& beta,
              const int& Q,
              const std::vector<int>& no,
              const std::vector<std::vector<int> >& prior_types,
              const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T4__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 301;
        int index(0);
        (void) index;  // dummy to suppress unused var warning

        stan::math::fill(index, std::numeric_limits<int>::min());
        stan::math::assign(index,1);
        current_statement_begin__ = 302;
        fun_scalar_t__ lpdf;
        (void) lpdf;  // dummy to suppress unused var warning

        stan::math::initialize(lpdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(lpdf,DUMMY_VAR__);
        stan::math::assign(lpdf,0);


        current_statement_begin__ = 304;
        for (int q = 1; q <= Q; ++q) {

            current_statement_begin__ = 305;
            if (as_bool(logical_gt(get_base1(no,q,"no",1),0))) {

                current_statement_begin__ = 306;
                for (int p = 1; p <= get_base1(no,q,"no",1); ++p) {

                    current_statement_begin__ = 307;
                    if (as_bool(logical_eq(get_base1(get_base1(prior_types,q,"prior_types",1),p,"prior_types",2),500))) {

                        current_statement_begin__ = 308;
                        stan::math::assign(lpdf, (lpdf + beta_cdf_log(get_base1(beta,index,"beta",1),get_base1(get_base1(get_base1(prior,p,"prior",1),1,"prior",2),q,"prior",3),get_base1(get_base1(get_base1(prior,p,"prior",1),2,"prior",2),q,"prior",3))));
                    }
                }
                current_statement_begin__ = 311;
                stan::math::assign(index, (index + 1));
            }
        }
        current_statement_begin__ = 315;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lpdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T4__>
typename boost::math::tools::promote_args<T0__, T4__>::type
unit_lpdf(const std::vector<T0__>& beta,
              const int& Q,
              const std::vector<int>& no,
              const std::vector<std::vector<int> >& prior_types,
              const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) {
    return unit_lpdf<false>(beta,Q,no,prior_types,prior, pstream__);
}


struct unit_lpdf_functor__ {
    template <bool propto, typename T0__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T4__>::type
    operator()(const std::vector<T0__>& beta,
              const int& Q,
              const std::vector<int>& no,
              const std::vector<std::vector<int> >& prior_types,
              const std::vector<std::vector<std::vector<T4__> > >& prior, std::ostream* pstream__) const {
        return unit_lpdf(beta, Q, no, prior_types, prior, pstream__);
    }
};

template <typename T6__, typename T7__, typename T8__, typename T12__>
std::vector<std::vector<typename boost::math::tools::promote_args<T6__, T7__, T8__, T12__>::type> >
get_parameters(const int& N,
                   const int& Q,
                   const int& P,
                   const std::vector<int>& no_unbounded,
                   const std::vector<int>& no_positive,
                   const std::vector<int>& no_unit,
                   const std::vector<T6__>& beta_unbounded,
                   const std::vector<T7__>& beta_positive,
                   const std::vector<T8__>& beta_unit,
                   const std::vector<std::vector<int> >& unbounded_indices,
                   const std::vector<std::vector<int> >& positive_indices,
                   const std::vector<std::vector<int> >& unit_indices,
                   const std::vector<std::vector<T12__> >& X,
                   const std::vector<int>& link_types, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T6__, T7__, T8__, T12__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 323;
        validate_non_negative_index("params", "N", N);
        validate_non_negative_index("params", "Q", Q);
        vector<vector<fun_scalar_t__> > params(N, (vector<fun_scalar_t__>(Q)));
        stan::math::initialize(params, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(params,DUMMY_VAR__);
        current_statement_begin__ = 325;
        int unbounded_index(0);
        (void) unbounded_index;  // dummy to suppress unused var warning

        stan::math::fill(unbounded_index, std::numeric_limits<int>::min());
        stan::math::assign(unbounded_index,1);
        current_statement_begin__ = 326;
        int positive_index(0);
        (void) positive_index;  // dummy to suppress unused var warning

        stan::math::fill(positive_index, std::numeric_limits<int>::min());
        stan::math::assign(positive_index,1);
        current_statement_begin__ = 327;
        int unit_index(0);
        (void) unit_index;  // dummy to suppress unused var warning

        stan::math::fill(unit_index, std::numeric_limits<int>::min());
        stan::math::assign(unit_index,1);


        current_statement_begin__ = 329;
        for (int n = 1; n <= N; ++n) {

            current_statement_begin__ = 330;
            for (int q = 1; q <= Q; ++q) {
                current_statement_begin__ = 330;
                stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), 0);
            }
        }
        current_statement_begin__ = 333;
        for (int q = 1; q <= Q; ++q) {

            current_statement_begin__ = 335;
            if (as_bool(logical_gt(get_base1(no_unbounded,q,"no_unbounded",1),0))) {

                current_statement_begin__ = 336;
                for (int p = 1; p <= P; ++p) {

                    current_statement_begin__ = 337;
                    if (as_bool(logical_eq(get_base1(get_base1(unbounded_indices,q,"unbounded_indices",1),p,"unbounded_indices",2),1))) {

                        current_statement_begin__ = 338;
                        for (int n = 1; n <= N; ++n) {

                            current_statement_begin__ = 339;
                            stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (get_base1(get_base1(params,n,"params",1),q,"params",2) + (get_base1(get_base1(X,n,"X",1),p,"X",2) * get_base1(beta_unbounded,unbounded_index,"beta_unbounded",1))));
                        }
                        current_statement_begin__ = 341;
                        stan::math::assign(unbounded_index, (unbounded_index + 1));
                    }
                }
            }
            current_statement_begin__ = 346;
            if (as_bool(logical_gt(get_base1(no_positive,q,"no_positive",1),0))) {

                current_statement_begin__ = 347;
                for (int p = 1; p <= P; ++p) {

                    current_statement_begin__ = 348;
                    if (as_bool(logical_eq(get_base1(get_base1(positive_indices,q,"positive_indices",1),p,"positive_indices",2),1))) {

                        current_statement_begin__ = 349;
                        for (int n = 1; n <= N; ++n) {

                            current_statement_begin__ = 350;
                            stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (get_base1(get_base1(params,n,"params",1),q,"params",2) + (get_base1(get_base1(X,n,"X",1),p,"X",2) * get_base1(beta_positive,positive_index,"beta_positive",1))));
                        }
                        current_statement_begin__ = 352;
                        stan::math::assign(positive_index, (positive_index + 1));
                    }
                }
            }
            current_statement_begin__ = 357;
            if (as_bool(logical_gt(get_base1(no_unit,q,"no_unit",1),0))) {

                current_statement_begin__ = 358;
                for (int p = 1; p <= P; ++p) {

                    current_statement_begin__ = 359;
                    if (as_bool(logical_eq(get_base1(get_base1(unit_indices,q,"unit_indices",1),p,"unit_indices",2),1))) {

                        current_statement_begin__ = 360;
                        for (int n = 1; n <= N; ++n) {

                            current_statement_begin__ = 361;
                            stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (get_base1(get_base1(params,n,"params",1),q,"params",2) + (get_base1(get_base1(X,n,"X",1),p,"X",2) * get_base1(beta_unit,unit_index,"beta_unit",1))));
                        }
                        current_statement_begin__ = 363;
                        stan::math::assign(unit_index, (unit_index + 1));
                    }
                }
            }
        }
        current_statement_begin__ = 371;
        for (int q = 1; q <= Q; ++q) {

            current_statement_begin__ = 372;
            if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),2))) {

                current_statement_begin__ = 373;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 373;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (1 / get_base1(get_base1(params,n,"params",1),q,"params",2)));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),3))) {

                current_statement_begin__ = 375;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 375;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (1 / sqrt(get_base1(get_base1(params,n,"params",1),q,"params",2))));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),4))) {

                current_statement_begin__ = 377;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 377;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), exp(get_base1(get_base1(params,n,"params",1),q,"params",2)));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),5))) {

                current_statement_begin__ = 379;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 379;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), pow(get_base1(get_base1(params,n,"params",1),q,"params",2),2));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),6))) {

                current_statement_begin__ = 381;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 381;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), normal_cdf(get_base1(get_base1(params,n,"params",1),q,"params",2),0,1));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),7))) {

                current_statement_begin__ = 383;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 383;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (1 - exp(-(exp(get_base1(get_base1(params,n,"params",1),q,"params",2))))));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),8))) {

                current_statement_begin__ = 385;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 385;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), (exp(get_base1(get_base1(params,n,"params",1),q,"params",2)) / (1 + exp(get_base1(get_base1(params,n,"params",1),q,"params",2)))));
                }
            } else if (as_bool(logical_eq(get_base1(link_types,q,"link_types",1),9))) {

                current_statement_begin__ = 387;
                for (int n = 1; n <= N; ++n) {
                    current_statement_begin__ = 387;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(params,n,"params",1),q,"params",2), cauchy_cdf(get_base1(get_base1(params,n,"params",1),q,"params",2),0,1));
                }
            }
        }
        current_statement_begin__ = 391;
        return stan::math::promote_scalar<fun_return_scalar_t__>(params);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_parameters_functor__ {
    template <typename T6__, typename T7__, typename T8__, typename T12__>
        std::vector<std::vector<typename boost::math::tools::promote_args<T6__, T7__, T8__, T12__>::type> >
    operator()(const int& N,
                   const int& Q,
                   const int& P,
                   const std::vector<int>& no_unbounded,
                   const std::vector<int>& no_positive,
                   const std::vector<int>& no_unit,
                   const std::vector<T6__>& beta_unbounded,
                   const std::vector<T7__>& beta_positive,
                   const std::vector<T8__>& beta_unit,
                   const std::vector<std::vector<int> >& unbounded_indices,
                   const std::vector<std::vector<int> >& positive_indices,
                   const std::vector<std::vector<int> >& unit_indices,
                   const std::vector<std::vector<T12__> >& X,
                   const std::vector<int>& link_types, std::ostream* pstream__) const {
        return get_parameters(N, Q, P, no_unbounded, no_positive, no_unit, beta_unbounded, beta_positive, beta_unit, unbounded_indices, positive_indices, unit_indices, X, link_types, pstream__);
    }
};

template <bool propto, typename T0__, typename T3__>
typename boost::math::tools::promote_args<T0__, T3__>::type
likelihood_lpdf(const std::vector<T0__>& Y,
                    const int& family,
                    const int& N,
                    const std::vector<std::vector<T3__> >& params, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 395;
        fun_scalar_t__ lcdf;
        (void) lcdf;  // dummy to suppress unused var warning

        stan::math::initialize(lcdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(lcdf,DUMMY_VAR__);
        stan::math::assign(lcdf,0);


        current_statement_begin__ = 397;
        if (as_bool(logical_eq(family,1))) {

            current_statement_begin__ = 399;
            for (int n = 1; n <= N; ++n) {

                current_statement_begin__ = 400;
                stan::math::assign(lcdf, (lcdf + normal_log(get_base1(Y,n,"Y",1),get_base1(get_base1(params,n,"params",1),1,"params",2),get_base1(get_base1(params,n,"params",1),2,"params",2))));
            }
        } else if (as_bool(logical_eq(family,2))) {

            current_statement_begin__ = 405;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 406;
                fun_scalar_t__ mean_;
                (void) mean_;  // dummy to suppress unused var warning

                stan::math::initialize(mean_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mean_,DUMMY_VAR__);
                stan::math::assign(mean_,get_base1(get_base1(params,n,"params",1),1,"params",2));
                current_statement_begin__ = 407;
                fun_scalar_t__ sd_;
                (void) sd_;  // dummy to suppress unused var warning

                stan::math::initialize(sd_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sd_,DUMMY_VAR__);
                stan::math::assign(sd_,get_base1(get_base1(params,n,"params",1),2,"params",2));
                current_statement_begin__ = 408;
                fun_scalar_t__ euler_mascheroni;
                (void) euler_mascheroni;  // dummy to suppress unused var warning

                stan::math::initialize(euler_mascheroni, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(euler_mascheroni,DUMMY_VAR__);
                stan::math::assign(euler_mascheroni,0.57721566490153198);
                current_statement_begin__ = 409;
                fun_scalar_t__ beta;
                (void) beta;  // dummy to suppress unused var warning

                stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(beta,DUMMY_VAR__);
                stan::math::assign(beta,(((1 / stan::math::pi()) * sqrt(6)) * sd_));
                current_statement_begin__ = 410;
                fun_scalar_t__ mu;
                (void) mu;  // dummy to suppress unused var warning

                stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu,DUMMY_VAR__);
                stan::math::assign(mu,(mean_ - (beta * euler_mascheroni)));


                current_statement_begin__ = 411;
                stan::math::assign(lcdf, (lcdf + gumbel_log(get_base1(Y,n,"Y",1),mu,beta)));
                }
            }
        } else if (as_bool(logical_eq(family,3))) {

            current_statement_begin__ = 416;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 417;
                fun_scalar_t__ mean_;
                (void) mean_;  // dummy to suppress unused var warning

                stan::math::initialize(mean_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mean_,DUMMY_VAR__);
                stan::math::assign(mean_,get_base1(get_base1(params,n,"params",1),1,"params",2));
                current_statement_begin__ = 418;
                fun_scalar_t__ sd_;
                (void) sd_;  // dummy to suppress unused var warning

                stan::math::initialize(sd_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sd_,DUMMY_VAR__);
                stan::math::assign(sd_,get_base1(get_base1(params,n,"params",1),2,"params",2));
                current_statement_begin__ = 419;
                fun_scalar_t__ alpha;
                (void) alpha;  // dummy to suppress unused var warning

                stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(alpha,DUMMY_VAR__);
                stan::math::assign(alpha,get_base1(get_base1(params,n,"params",1),3,"params",2));
                current_statement_begin__ = 421;
                fun_scalar_t__ delta;
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                stan::math::assign(delta,(alpha / sqrt((1 + pow(alpha,2)))));
                current_statement_begin__ = 422;
                fun_scalar_t__ omega;
                (void) omega;  // dummy to suppress unused var warning

                stan::math::initialize(omega, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(omega,DUMMY_VAR__);
                stan::math::assign(omega,(sd_ / sqrt((1 - ((pow(delta,2) * 2) / stan::math::pi())))));
                current_statement_begin__ = 423;
                fun_scalar_t__ xi;
                (void) xi;  // dummy to suppress unused var warning

                stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(xi,DUMMY_VAR__);
                stan::math::assign(xi,(mean_ - (omega * (delta * sqrt((2 / stan::math::pi()))))));


                current_statement_begin__ = 425;
                stan::math::assign(lcdf, (lcdf + skew_normal_log(get_base1(Y,n,"Y",1),xi,omega,alpha)));
                }
            }
        } else if (as_bool(logical_eq(family,4))) {

            current_statement_begin__ = 430;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 431;
                fun_scalar_t__ mean_;
                (void) mean_;  // dummy to suppress unused var warning

                stan::math::initialize(mean_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mean_,DUMMY_VAR__);
                stan::math::assign(mean_,get_base1(get_base1(params,n,"params",1),1,"params",2));
                current_statement_begin__ = 432;
                fun_scalar_t__ var_;
                (void) var_;  // dummy to suppress unused var warning

                stan::math::initialize(var_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(var_,DUMMY_VAR__);
                stan::math::assign(var_,pow(get_base1(get_base1(params,n,"params",1),2,"params",2),2));
                current_statement_begin__ = 434;
                fun_scalar_t__ shape;
                (void) shape;  // dummy to suppress unused var warning

                stan::math::initialize(shape, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(shape,DUMMY_VAR__);
                stan::math::assign(shape,(pow(mean_,2) / var_));
                current_statement_begin__ = 435;
                fun_scalar_t__ rate;
                (void) rate;  // dummy to suppress unused var warning

                stan::math::initialize(rate, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(rate,DUMMY_VAR__);
                stan::math::assign(rate,(mean_ / var_));


                current_statement_begin__ = 437;
                stan::math::assign(lcdf, (lcdf + gamma_log(get_base1(Y,n,"Y",1),shape,rate)));
                }
            }
        } else if (as_bool(logical_eq(family,5))) {

            current_statement_begin__ = 442;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 443;
                fun_scalar_t__ mean_;
                (void) mean_;  // dummy to suppress unused var warning

                stan::math::initialize(mean_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mean_,DUMMY_VAR__);
                stan::math::assign(mean_,get_base1(get_base1(params,n,"params",1),1,"params",2));
                current_statement_begin__ = 444;
                fun_scalar_t__ var_;
                (void) var_;  // dummy to suppress unused var warning

                stan::math::initialize(var_, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(var_,DUMMY_VAR__);
                stan::math::assign(var_,pow(get_base1(get_base1(params,n,"params",1),2,"params",2),2));
                current_statement_begin__ = 446;
                fun_scalar_t__ sigma_sqr;
                (void) sigma_sqr;  // dummy to suppress unused var warning

                stan::math::initialize(sigma_sqr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sigma_sqr,DUMMY_VAR__);
                stan::math::assign(sigma_sqr,(log((var_ + pow(mean_,2))) - (2 * log(mean_))));
                current_statement_begin__ = 447;
                fun_scalar_t__ mu;
                (void) mu;  // dummy to suppress unused var warning

                stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu,DUMMY_VAR__);
                stan::math::assign(mu,(log(mean_) - (sigma_sqr / 2)));


                current_statement_begin__ = 449;
                stan::math::assign(lcdf, (lcdf + lognormal_log(get_base1(Y,n,"Y",1),mu,sqrt(sigma_sqr))));
                }
            }
        } else if (as_bool(logical_eq(family,6))) {

            current_statement_begin__ = 454;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 455;
                fun_scalar_t__ mu;
                (void) mu;  // dummy to suppress unused var warning

                stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu,DUMMY_VAR__);
                stan::math::assign(mu,get_base1(get_base1(params,n,"params",1),1,"params",2));
                current_statement_begin__ = 456;
                fun_scalar_t__ lambda;
                (void) lambda;  // dummy to suppress unused var warning

                stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(lambda,DUMMY_VAR__);
                stan::math::assign(lambda,(pow(mu,3) / pow(get_base1(get_base1(params,n,"params",1),2,"params",2),2)));


                current_statement_begin__ = 458;
                stan::math::assign(lcdf, (lcdf + inverse_gaussian_lpdf(get_base1(Y,n,"Y",1),mu,lambda, pstream__)));
                }
            }
        } else if (as_bool(logical_eq(family,7))) {

            current_statement_begin__ = 463;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 464;
                fun_scalar_t__ alpha;
                (void) alpha;  // dummy to suppress unused var warning

                stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(alpha,DUMMY_VAR__);
                stan::math::assign(alpha,(get_base1(get_base1(params,n,"params",1),1,"params",2) * get_base1(get_base1(params,n,"params",1),2,"params",2)));
                current_statement_begin__ = 465;
                fun_scalar_t__ beta;
                (void) beta;  // dummy to suppress unused var warning

                stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(beta,DUMMY_VAR__);
                stan::math::assign(beta,((1 - get_base1(get_base1(params,n,"params",1),2,"params",2)) * get_base1(get_base1(params,n,"params",1),2,"params",2)));


                current_statement_begin__ = 467;
                stan::math::assign(lcdf, (lcdf + beta_log(get_base1(Y,n,"Y",1),alpha,beta)));
                }
            }
        } else if (as_bool(logical_eq(family,8))) {

            current_statement_begin__ = 472;
            for (int n = 1; n <= N; ++n) {
                {
                current_statement_begin__ = 473;
                fun_scalar_t__ mu;
                (void) mu;  // dummy to suppress unused var warning

                stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu,DUMMY_VAR__);
                stan::math::assign(mu,get_base1(get_base1(params,n,"params",1),1,"params",2));
                current_statement_begin__ = 474;
                fun_scalar_t__ sigma;
                (void) sigma;  // dummy to suppress unused var warning

                stan::math::initialize(sigma, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sigma,DUMMY_VAR__);
                stan::math::assign(sigma,get_base1(get_base1(params,n,"params",1),2,"params",2));
                current_statement_begin__ = 475;
                fun_scalar_t__ lambda;
                (void) lambda;  // dummy to suppress unused var warning

                stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(lambda,DUMMY_VAR__);
                stan::math::assign(lambda,get_base1(get_base1(params,n,"params",1),3,"params",2));


                current_statement_begin__ = 477;
                stan::math::assign(lcdf, (lcdf + exp_mod_normal_log(get_base1(Y,n,"Y",1),mu,sigma,lambda)));
                }
            }
        } else if (as_bool(logical_eq(family,9))) {

            current_statement_begin__ = 482;
            for (int n = 1; n <= N; ++n) {

                current_statement_begin__ = 483;
                stan::math::assign(lcdf, (lcdf + fnormal_lpdf(get_base1(Y,n,"Y",1),get_base1(get_base1(params,n,"params",1),1,"params",2),get_base1(get_base1(params,n,"params",1),2,"params",2), pstream__)));
            }
        } else if (as_bool(logical_eq(family,10))) {

            current_statement_begin__ = 488;
            for (int n = 1; n <= N; ++n) {

                current_statement_begin__ = 489;
                stan::math::assign(lcdf, (lcdf + lower_normal_lpdf(get_base1(Y,n,"Y",1),get_base1(get_base1(params,n,"params",1),1,"params",2),get_base1(get_base1(params,n,"params",1),2,"params",2),0, pstream__)));
            }
        }
        current_statement_begin__ = 494;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lcdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T3__>
typename boost::math::tools::promote_args<T0__, T3__>::type
likelihood_lpdf(const std::vector<T0__>& Y,
                    const int& family,
                    const int& N,
                    const std::vector<std::vector<T3__> >& params, std::ostream* pstream__) {
    return likelihood_lpdf<false>(Y,family,N,params, pstream__);
}


struct likelihood_lpdf_functor__ {
    template <bool propto, typename T0__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T3__>::type
    operator()(const std::vector<T0__>& Y,
                    const int& family,
                    const int& N,
                    const std::vector<std::vector<T3__> >& params, std::ostream* pstream__) const {
        return likelihood_lpdf(Y, family, N, params, pstream__);
    }
};

template <bool propto, typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T7__>
typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T7__>::type>::type
distributions_lpdf(const std::vector<T0__>& Z,
                       const int& N,
                       const std::vector<T2__>& thetas,
                       const std::vector<T3__>& SQRT_M,
                       const std::vector<T4__>& lower_bounds,
                       const std::vector<T5__>& upper_bounds,
                       const std::vector<int>& dist_indices,
                       const std::vector<T7__>& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T7__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 499;
        fun_scalar_t__ lpdf;
        (void) lpdf;  // dummy to suppress unused var warning

        stan::math::initialize(lpdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(lpdf,DUMMY_VAR__);
        stan::math::assign(lpdf,0);


        current_statement_begin__ = 503;
        for (int n = 1; n <= N; ++n) {

            current_statement_begin__ = 504;
            if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),1))) {

                current_statement_begin__ = 507;
                stan::math::assign(lpdf, (lpdf + mix_fnormal_lower_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(lower_bounds,n,"lower_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),2))) {

                current_statement_begin__ = 512;
                stan::math::assign(lpdf, (lpdf + mix_fnormal_upper_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(upper_bounds,n,"upper_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),3))) {

                current_statement_begin__ = 517;
                stan::math::assign(lpdf, (lpdf + mix_fnormal_double_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),4))) {

                current_statement_begin__ = 522;
                stan::math::assign(lpdf, (lpdf + mix_fnormal_inner_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),5))) {

                current_statement_begin__ = 527;
                stan::math::assign(lpdf, (lpdf + mix_normal_lower_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(lower_bounds,n,"lower_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),6))) {

                current_statement_begin__ = 532;
                stan::math::assign(lpdf, (lpdf + mix_normal_upper_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(upper_bounds,n,"upper_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),7))) {

                current_statement_begin__ = 537;
                stan::math::assign(lpdf, (lpdf + mix_normal_double_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),8))) {

                current_statement_begin__ = 542;
                stan::math::assign(lpdf, (lpdf + mix_normal_inner_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1),get_base1(p,n,"p",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),9))) {

                current_statement_begin__ = 547;
                stan::math::assign(lpdf, (lpdf + fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1, pstream__)));
                current_statement_begin__ = 548;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),10))) {

                current_statement_begin__ = 553;
                stan::math::assign(lpdf, (lpdf + fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1, pstream__)));
                current_statement_begin__ = 554;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),11))) {

                current_statement_begin__ = 559;
                stan::math::assign(lpdf, (lpdf + lower_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1), pstream__)));
                current_statement_begin__ = 560;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),12))) {

                current_statement_begin__ = 565;
                stan::math::assign(lpdf, (lpdf + upper_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
                current_statement_begin__ = 566;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),13))) {

                current_statement_begin__ = 571;
                stan::math::assign(lpdf, (lpdf + double_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
                current_statement_begin__ = 572;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),14))) {

                current_statement_begin__ = 577;
                stan::math::assign(lpdf, (lpdf + inner_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
                current_statement_begin__ = 578;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),15))) {

                current_statement_begin__ = 583;
                stan::math::assign(lpdf, (lpdf + lower_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1), pstream__)));
                current_statement_begin__ = 584;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),16))) {

                current_statement_begin__ = 589;
                stan::math::assign(lpdf, (lpdf + upper_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
                current_statement_begin__ = 590;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),17))) {

                current_statement_begin__ = 595;
                stan::math::assign(lpdf, (lpdf + double_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
                current_statement_begin__ = 596;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),18))) {

                current_statement_begin__ = 601;
                stan::math::assign(lpdf, (lpdf + inner_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
                current_statement_begin__ = 602;
                stan::math::assign(lpdf, (lpdf + bernoulli_log(0,get_base1(p,n,"p",1))));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),19))) {

                current_statement_begin__ = 607;
                stan::math::assign(lpdf, (lpdf + fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1, pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),20))) {

                current_statement_begin__ = 612;
                stan::math::assign(lpdf, (lpdf + normal_log(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),21))) {

                current_statement_begin__ = 617;
                stan::math::assign(lpdf, (lpdf + lower_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),22))) {

                current_statement_begin__ = 622;
                stan::math::assign(lpdf, (lpdf + upper_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),23))) {

                current_statement_begin__ = 627;
                stan::math::assign(lpdf, (lpdf + double_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),24))) {

                current_statement_begin__ = 632;
                stan::math::assign(lpdf, (lpdf + inner_fnormal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),25))) {

                current_statement_begin__ = 637;
                stan::math::assign(lpdf, (lpdf + lower_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),26))) {

                current_statement_begin__ = 642;
                stan::math::assign(lpdf, (lpdf + upper_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),27))) {

                current_statement_begin__ = 647;
                stan::math::assign(lpdf, (lpdf + double_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
            } else if (as_bool(logical_eq(get_base1(dist_indices,n,"dist_indices",1),28))) {

                current_statement_begin__ = 652;
                stan::math::assign(lpdf, (lpdf + inner_normal_lpdf(get_base1(Z,n,"Z",1),(get_base1(SQRT_M,n,"SQRT_M",1) * get_base1(thetas,n,"thetas",1)),1,get_base1(lower_bounds,n,"lower_bounds",1),get_base1(upper_bounds,n,"upper_bounds",1), pstream__)));
            }
        }
        current_statement_begin__ = 658;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lpdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T7__>
typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T7__>::type>::type
distributions_lpdf(const std::vector<T0__>& Z,
                       const int& N,
                       const std::vector<T2__>& thetas,
                       const std::vector<T3__>& SQRT_M,
                       const std::vector<T4__>& lower_bounds,
                       const std::vector<T5__>& upper_bounds,
                       const std::vector<int>& dist_indices,
                       const std::vector<T7__>& p, std::ostream* pstream__) {
    return distributions_lpdf<false>(Z,N,thetas,SQRT_M,lower_bounds,upper_bounds,dist_indices,p, pstream__);
}


struct distributions_lpdf_functor__ {
    template <bool propto, typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T7__>
        typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T7__>::type>::type
    operator()(const std::vector<T0__>& Z,
                       const int& N,
                       const std::vector<T2__>& thetas,
                       const std::vector<T3__>& SQRT_M,
                       const std::vector<T4__>& lower_bounds,
                       const std::vector<T5__>& upper_bounds,
                       const std::vector<int>& dist_indices,
                       const std::vector<T7__>& p, std::ostream* pstream__) const {
        return distributions_lpdf(Z, N, thetas, SQRT_M, lower_bounds, upper_bounds, dist_indices, p, pstream__);
    }
};

#include <meta_header.hpp>
 class model_straussR_mixed : public prob_grad {
private:
    int MAX_PAR;
    int N_unbounded;
    int N_positive;
    int N_unit;
    int N;
    int P;
    int Q;
    int family;
    int family_type;
    vector<int> link_types;
    vector<double> M;
    vector<double> lower_bounds;
    vector<double> upper_bounds;
    vector<double> Z;
    vector<vector<double> > X;
    vector<int> dist_indices;
    vector<int> no_unbounded;
    vector<int> no_positive;
    vector<int> no_unit;
    vector<vector<int> > unbounded_indices;
    vector<vector<int> > positive_indices;
    vector<vector<int> > unit_indices;
    vector<vector<vector<double> > > unbounded_prior;
    vector<vector<vector<double> > > positive_prior;
    vector<vector<vector<double> > > unit_prior;
    vector<vector<int> > positive_prior_types;
    vector<vector<int> > unbounded_prior_types;
    vector<vector<int> > unit_prior_types;
    vector<double> SQRT_M;
public:
    model_straussR_mixed(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_straussR_mixed(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_straussR_mixed_namespace::model_straussR_mixed";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 665;
            context__.validate_dims("data initialization", "MAX_PAR", "int", context__.to_vec());
            MAX_PAR = int(0);
            vals_i__ = context__.vals_i("MAX_PAR");
            pos__ = 0;
            MAX_PAR = vals_i__[pos__++];
            current_statement_begin__ = 666;
            context__.validate_dims("data initialization", "N_unbounded", "int", context__.to_vec());
            N_unbounded = int(0);
            vals_i__ = context__.vals_i("N_unbounded");
            pos__ = 0;
            N_unbounded = vals_i__[pos__++];
            current_statement_begin__ = 667;
            context__.validate_dims("data initialization", "N_positive", "int", context__.to_vec());
            N_positive = int(0);
            vals_i__ = context__.vals_i("N_positive");
            pos__ = 0;
            N_positive = vals_i__[pos__++];
            current_statement_begin__ = 668;
            context__.validate_dims("data initialization", "N_unit", "int", context__.to_vec());
            N_unit = int(0);
            vals_i__ = context__.vals_i("N_unit");
            pos__ = 0;
            N_unit = vals_i__[pos__++];
            current_statement_begin__ = 669;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 670;
            context__.validate_dims("data initialization", "P", "int", context__.to_vec());
            P = int(0);
            vals_i__ = context__.vals_i("P");
            pos__ = 0;
            P = vals_i__[pos__++];
            current_statement_begin__ = 671;
            context__.validate_dims("data initialization", "Q", "int", context__.to_vec());
            Q = int(0);
            vals_i__ = context__.vals_i("Q");
            pos__ = 0;
            Q = vals_i__[pos__++];
            current_statement_begin__ = 673;
            context__.validate_dims("data initialization", "family", "int", context__.to_vec());
            family = int(0);
            vals_i__ = context__.vals_i("family");
            pos__ = 0;
            family = vals_i__[pos__++];
            current_statement_begin__ = 674;
            context__.validate_dims("data initialization", "family_type", "int", context__.to_vec());
            family_type = int(0);
            vals_i__ = context__.vals_i("family_type");
            pos__ = 0;
            family_type = vals_i__[pos__++];
            current_statement_begin__ = 675;
            validate_non_negative_index("link_types", "Q", Q);
            context__.validate_dims("data initialization", "link_types", "int", context__.to_vec(Q));
            validate_non_negative_index("link_types", "Q", Q);
            link_types = std::vector<int>(Q,int(0));
            vals_i__ = context__.vals_i("link_types");
            pos__ = 0;
            size_t link_types_limit_0__ = Q;
            for (size_t i_0__ = 0; i_0__ < link_types_limit_0__; ++i_0__) {
                link_types[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 677;
            validate_non_negative_index("M", "N", N);
            context__.validate_dims("data initialization", "M", "double", context__.to_vec(N));
            validate_non_negative_index("M", "N", N);
            M = std::vector<double>(N,double(0));
            vals_r__ = context__.vals_r("M");
            pos__ = 0;
            size_t M_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < M_limit_0__; ++i_0__) {
                M[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 678;
            validate_non_negative_index("lower_bounds", "N", N);
            context__.validate_dims("data initialization", "lower_bounds", "double", context__.to_vec(N));
            validate_non_negative_index("lower_bounds", "N", N);
            lower_bounds = std::vector<double>(N,double(0));
            vals_r__ = context__.vals_r("lower_bounds");
            pos__ = 0;
            size_t lower_bounds_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < lower_bounds_limit_0__; ++i_0__) {
                lower_bounds[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 679;
            validate_non_negative_index("upper_bounds", "N", N);
            context__.validate_dims("data initialization", "upper_bounds", "double", context__.to_vec(N));
            validate_non_negative_index("upper_bounds", "N", N);
            upper_bounds = std::vector<double>(N,double(0));
            vals_r__ = context__.vals_r("upper_bounds");
            pos__ = 0;
            size_t upper_bounds_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < upper_bounds_limit_0__; ++i_0__) {
                upper_bounds[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 680;
            validate_non_negative_index("Z", "N", N);
            context__.validate_dims("data initialization", "Z", "double", context__.to_vec(N));
            validate_non_negative_index("Z", "N", N);
            Z = std::vector<double>(N,double(0));
            vals_r__ = context__.vals_r("Z");
            pos__ = 0;
            size_t Z_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Z_limit_0__; ++i_0__) {
                Z[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 681;
            validate_non_negative_index("X", "N", N);
            validate_non_negative_index("X", "P", P);
            context__.validate_dims("data initialization", "X", "double", context__.to_vec(N,P));
            validate_non_negative_index("X", "N", N);
            validate_non_negative_index("X", "P", P);
            X = std::vector<std::vector<double> >(N,std::vector<double>(P,double(0)));
            vals_r__ = context__.vals_r("X");
            pos__ = 0;
            size_t X_limit_1__ = P;
            for (size_t i_1__ = 0; i_1__ < X_limit_1__; ++i_1__) {
                size_t X_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < X_limit_0__; ++i_0__) {
                    X[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 686;
            validate_non_negative_index("dist_indices", "N", N);
            context__.validate_dims("data initialization", "dist_indices", "int", context__.to_vec(N));
            validate_non_negative_index("dist_indices", "N", N);
            dist_indices = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("dist_indices");
            pos__ = 0;
            size_t dist_indices_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < dist_indices_limit_0__; ++i_0__) {
                dist_indices[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 693;
            validate_non_negative_index("no_unbounded", "Q", Q);
            context__.validate_dims("data initialization", "no_unbounded", "int", context__.to_vec(Q));
            validate_non_negative_index("no_unbounded", "Q", Q);
            no_unbounded = std::vector<int>(Q,int(0));
            vals_i__ = context__.vals_i("no_unbounded");
            pos__ = 0;
            size_t no_unbounded_limit_0__ = Q;
            for (size_t i_0__ = 0; i_0__ < no_unbounded_limit_0__; ++i_0__) {
                no_unbounded[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 694;
            validate_non_negative_index("no_positive", "Q", Q);
            context__.validate_dims("data initialization", "no_positive", "int", context__.to_vec(Q));
            validate_non_negative_index("no_positive", "Q", Q);
            no_positive = std::vector<int>(Q,int(0));
            vals_i__ = context__.vals_i("no_positive");
            pos__ = 0;
            size_t no_positive_limit_0__ = Q;
            for (size_t i_0__ = 0; i_0__ < no_positive_limit_0__; ++i_0__) {
                no_positive[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 695;
            validate_non_negative_index("no_unit", "Q", Q);
            context__.validate_dims("data initialization", "no_unit", "int", context__.to_vec(Q));
            validate_non_negative_index("no_unit", "Q", Q);
            no_unit = std::vector<int>(Q,int(0));
            vals_i__ = context__.vals_i("no_unit");
            pos__ = 0;
            size_t no_unit_limit_0__ = Q;
            for (size_t i_0__ = 0; i_0__ < no_unit_limit_0__; ++i_0__) {
                no_unit[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 698;
            validate_non_negative_index("unbounded_indices", "Q", Q);
            validate_non_negative_index("unbounded_indices", "P", P);
            context__.validate_dims("data initialization", "unbounded_indices", "int", context__.to_vec(Q,P));
            validate_non_negative_index("unbounded_indices", "Q", Q);
            validate_non_negative_index("unbounded_indices", "P", P);
            unbounded_indices = std::vector<std::vector<int> >(Q,std::vector<int>(P,int(0)));
            vals_i__ = context__.vals_i("unbounded_indices");
            pos__ = 0;
            size_t unbounded_indices_limit_1__ = P;
            for (size_t i_1__ = 0; i_1__ < unbounded_indices_limit_1__; ++i_1__) {
                size_t unbounded_indices_limit_0__ = Q;
                for (size_t i_0__ = 0; i_0__ < unbounded_indices_limit_0__; ++i_0__) {
                    unbounded_indices[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 699;
            validate_non_negative_index("positive_indices", "Q", Q);
            validate_non_negative_index("positive_indices", "P", P);
            context__.validate_dims("data initialization", "positive_indices", "int", context__.to_vec(Q,P));
            validate_non_negative_index("positive_indices", "Q", Q);
            validate_non_negative_index("positive_indices", "P", P);
            positive_indices = std::vector<std::vector<int> >(Q,std::vector<int>(P,int(0)));
            vals_i__ = context__.vals_i("positive_indices");
            pos__ = 0;
            size_t positive_indices_limit_1__ = P;
            for (size_t i_1__ = 0; i_1__ < positive_indices_limit_1__; ++i_1__) {
                size_t positive_indices_limit_0__ = Q;
                for (size_t i_0__ = 0; i_0__ < positive_indices_limit_0__; ++i_0__) {
                    positive_indices[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 700;
            validate_non_negative_index("unit_indices", "Q", Q);
            validate_non_negative_index("unit_indices", "P", P);
            context__.validate_dims("data initialization", "unit_indices", "int", context__.to_vec(Q,P));
            validate_non_negative_index("unit_indices", "Q", Q);
            validate_non_negative_index("unit_indices", "P", P);
            unit_indices = std::vector<std::vector<int> >(Q,std::vector<int>(P,int(0)));
            vals_i__ = context__.vals_i("unit_indices");
            pos__ = 0;
            size_t unit_indices_limit_1__ = P;
            for (size_t i_1__ = 0; i_1__ < unit_indices_limit_1__; ++i_1__) {
                size_t unit_indices_limit_0__ = Q;
                for (size_t i_0__ = 0; i_0__ < unit_indices_limit_0__; ++i_0__) {
                    unit_indices[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 703;
            validate_non_negative_index("unbounded_prior", "max(no_unbounded)", max(no_unbounded));
            validate_non_negative_index("unbounded_prior", "MAX_PAR", MAX_PAR);
            validate_non_negative_index("unbounded_prior", "Q", Q);
            context__.validate_dims("data initialization", "unbounded_prior", "double", context__.to_vec(max(no_unbounded),MAX_PAR,Q));
            validate_non_negative_index("unbounded_prior", "max(no_unbounded)", max(no_unbounded));
            validate_non_negative_index("unbounded_prior", "MAX_PAR", MAX_PAR);
            validate_non_negative_index("unbounded_prior", "Q", Q);
            unbounded_prior = std::vector<std::vector<std::vector<double> > >(max(no_unbounded),std::vector<std::vector<double> >(MAX_PAR,std::vector<double>(Q,double(0))));
            vals_r__ = context__.vals_r("unbounded_prior");
            pos__ = 0;
            size_t unbounded_prior_limit_2__ = Q;
            for (size_t i_2__ = 0; i_2__ < unbounded_prior_limit_2__; ++i_2__) {
                size_t unbounded_prior_limit_1__ = MAX_PAR;
                for (size_t i_1__ = 0; i_1__ < unbounded_prior_limit_1__; ++i_1__) {
                    size_t unbounded_prior_limit_0__ = max(no_unbounded);
                    for (size_t i_0__ = 0; i_0__ < unbounded_prior_limit_0__; ++i_0__) {
                        unbounded_prior[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }
            current_statement_begin__ = 704;
            validate_non_negative_index("positive_prior", "max(no_positive)", max(no_positive));
            validate_non_negative_index("positive_prior", "MAX_PAR", MAX_PAR);
            validate_non_negative_index("positive_prior", "Q", Q);
            context__.validate_dims("data initialization", "positive_prior", "double", context__.to_vec(max(no_positive),MAX_PAR,Q));
            validate_non_negative_index("positive_prior", "max(no_positive)", max(no_positive));
            validate_non_negative_index("positive_prior", "MAX_PAR", MAX_PAR);
            validate_non_negative_index("positive_prior", "Q", Q);
            positive_prior = std::vector<std::vector<std::vector<double> > >(max(no_positive),std::vector<std::vector<double> >(MAX_PAR,std::vector<double>(Q,double(0))));
            vals_r__ = context__.vals_r("positive_prior");
            pos__ = 0;
            size_t positive_prior_limit_2__ = Q;
            for (size_t i_2__ = 0; i_2__ < positive_prior_limit_2__; ++i_2__) {
                size_t positive_prior_limit_1__ = MAX_PAR;
                for (size_t i_1__ = 0; i_1__ < positive_prior_limit_1__; ++i_1__) {
                    size_t positive_prior_limit_0__ = max(no_positive);
                    for (size_t i_0__ = 0; i_0__ < positive_prior_limit_0__; ++i_0__) {
                        positive_prior[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }
            current_statement_begin__ = 705;
            validate_non_negative_index("unit_prior", "max(no_unit)", max(no_unit));
            validate_non_negative_index("unit_prior", "MAX_PAR", MAX_PAR);
            validate_non_negative_index("unit_prior", "Q", Q);
            context__.validate_dims("data initialization", "unit_prior", "double", context__.to_vec(max(no_unit),MAX_PAR,Q));
            validate_non_negative_index("unit_prior", "max(no_unit)", max(no_unit));
            validate_non_negative_index("unit_prior", "MAX_PAR", MAX_PAR);
            validate_non_negative_index("unit_prior", "Q", Q);
            unit_prior = std::vector<std::vector<std::vector<double> > >(max(no_unit),std::vector<std::vector<double> >(MAX_PAR,std::vector<double>(Q,double(0))));
            vals_r__ = context__.vals_r("unit_prior");
            pos__ = 0;
            size_t unit_prior_limit_2__ = Q;
            for (size_t i_2__ = 0; i_2__ < unit_prior_limit_2__; ++i_2__) {
                size_t unit_prior_limit_1__ = MAX_PAR;
                for (size_t i_1__ = 0; i_1__ < unit_prior_limit_1__; ++i_1__) {
                    size_t unit_prior_limit_0__ = max(no_unit);
                    for (size_t i_0__ = 0; i_0__ < unit_prior_limit_0__; ++i_0__) {
                        unit_prior[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }
            current_statement_begin__ = 708;
            validate_non_negative_index("positive_prior_types", "Q", Q);
            validate_non_negative_index("positive_prior_types", "max(no_positive)", max(no_positive));
            context__.validate_dims("data initialization", "positive_prior_types", "int", context__.to_vec(Q,max(no_positive)));
            validate_non_negative_index("positive_prior_types", "Q", Q);
            validate_non_negative_index("positive_prior_types", "max(no_positive)", max(no_positive));
            positive_prior_types = std::vector<std::vector<int> >(Q,std::vector<int>(max(no_positive),int(0)));
            vals_i__ = context__.vals_i("positive_prior_types");
            pos__ = 0;
            size_t positive_prior_types_limit_1__ = max(no_positive);
            for (size_t i_1__ = 0; i_1__ < positive_prior_types_limit_1__; ++i_1__) {
                size_t positive_prior_types_limit_0__ = Q;
                for (size_t i_0__ = 0; i_0__ < positive_prior_types_limit_0__; ++i_0__) {
                    positive_prior_types[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 709;
            validate_non_negative_index("unbounded_prior_types", "Q", Q);
            validate_non_negative_index("unbounded_prior_types", "max(no_unbounded)", max(no_unbounded));
            context__.validate_dims("data initialization", "unbounded_prior_types", "int", context__.to_vec(Q,max(no_unbounded)));
            validate_non_negative_index("unbounded_prior_types", "Q", Q);
            validate_non_negative_index("unbounded_prior_types", "max(no_unbounded)", max(no_unbounded));
            unbounded_prior_types = std::vector<std::vector<int> >(Q,std::vector<int>(max(no_unbounded),int(0)));
            vals_i__ = context__.vals_i("unbounded_prior_types");
            pos__ = 0;
            size_t unbounded_prior_types_limit_1__ = max(no_unbounded);
            for (size_t i_1__ = 0; i_1__ < unbounded_prior_types_limit_1__; ++i_1__) {
                size_t unbounded_prior_types_limit_0__ = Q;
                for (size_t i_0__ = 0; i_0__ < unbounded_prior_types_limit_0__; ++i_0__) {
                    unbounded_prior_types[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 710;
            validate_non_negative_index("unit_prior_types", "Q", Q);
            validate_non_negative_index("unit_prior_types", "max(no_unit)", max(no_unit));
            context__.validate_dims("data initialization", "unit_prior_types", "int", context__.to_vec(Q,max(no_unit)));
            validate_non_negative_index("unit_prior_types", "Q", Q);
            validate_non_negative_index("unit_prior_types", "max(no_unit)", max(no_unit));
            unit_prior_types = std::vector<std::vector<int> >(Q,std::vector<int>(max(no_unit),int(0)));
            vals_i__ = context__.vals_i("unit_prior_types");
            pos__ = 0;
            size_t unit_prior_types_limit_1__ = max(no_unit);
            for (size_t i_1__ = 0; i_1__ < unit_prior_types_limit_1__; ++i_1__) {
                size_t unit_prior_types_limit_0__ = Q;
                for (size_t i_0__ = 0; i_0__ < unit_prior_types_limit_0__; ++i_0__) {
                    unit_prior_types[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 665;
            check_greater_or_equal(function__,"MAX_PAR",MAX_PAR,0);
            current_statement_begin__ = 666;
            check_greater_or_equal(function__,"N_unbounded",N_unbounded,0);
            current_statement_begin__ = 667;
            check_greater_or_equal(function__,"N_positive",N_positive,0);
            current_statement_begin__ = 668;
            check_greater_or_equal(function__,"N_unit",N_unit,0);
            current_statement_begin__ = 669;
            check_greater_or_equal(function__,"N",N,0);
            current_statement_begin__ = 670;
            check_greater_or_equal(function__,"P",P,0);
            current_statement_begin__ = 671;
            check_greater_or_equal(function__,"Q",Q,0);
            current_statement_begin__ = 673;
            check_greater_or_equal(function__,"family",family,0);
            current_statement_begin__ = 674;
            check_greater_or_equal(function__,"family_type",family_type,0);
            current_statement_begin__ = 675;
            current_statement_begin__ = 677;
            current_statement_begin__ = 678;
            current_statement_begin__ = 679;
            current_statement_begin__ = 680;
            current_statement_begin__ = 681;
            current_statement_begin__ = 686;
            current_statement_begin__ = 693;
            for (int k0__ = 0; k0__ < Q; ++k0__) {
                check_greater_or_equal(function__,"no_unbounded[k0__]",no_unbounded[k0__],0);
            }
            current_statement_begin__ = 694;
            for (int k0__ = 0; k0__ < Q; ++k0__) {
                check_greater_or_equal(function__,"no_positive[k0__]",no_positive[k0__],0);
            }
            current_statement_begin__ = 695;
            for (int k0__ = 0; k0__ < Q; ++k0__) {
                check_greater_or_equal(function__,"no_unit[k0__]",no_unit[k0__],0);
            }
            current_statement_begin__ = 698;
            current_statement_begin__ = 699;
            current_statement_begin__ = 700;
            current_statement_begin__ = 703;
            current_statement_begin__ = 704;
            current_statement_begin__ = 705;
            current_statement_begin__ = 708;
            current_statement_begin__ = 709;
            current_statement_begin__ = 710;
            // initialize data variables
            current_statement_begin__ = 715;
            validate_non_negative_index("SQRT_M", "N", N);
            SQRT_M = std::vector<double>(N,double(0));
            stan::math::fill(SQRT_M,DUMMY_VAR__);
            stan::math::assign(SQRT_M,sqrt(M));


            // validate transformed data
            current_statement_begin__ = 715;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 720;
            validate_non_negative_index("beta_unbounded", "sum(no_unbounded)", sum(no_unbounded));
            num_params_r__ += sum(no_unbounded);
            current_statement_begin__ = 721;
            validate_non_negative_index("beta_positive", "sum(no_positive)", sum(no_positive));
            num_params_r__ += sum(no_positive);
            current_statement_begin__ = 722;
            validate_non_negative_index("beta_unit", "sum(no_unit)", sum(no_unit));
            num_params_r__ += sum(no_unit);
            current_statement_begin__ = 725;
            validate_non_negative_index("thetas_unbounded", "N_unbounded", N_unbounded);
            num_params_r__ += N_unbounded;
            current_statement_begin__ = 726;
            validate_non_negative_index("thetas_positive", "N_positive", N_positive);
            num_params_r__ += N_positive;
            current_statement_begin__ = 727;
            validate_non_negative_index("thetas_unit", "N_unit", N_unit);
            num_params_r__ += N_unit;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_straussR_mixed() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("beta_unbounded")))
            throw std::runtime_error("variable beta_unbounded missing");
        vals_r__ = context__.vals_r("beta_unbounded");
        pos__ = 0U;
        validate_non_negative_index("beta_unbounded", "sum(no_unbounded)", sum(no_unbounded));
        context__.validate_dims("initialization", "beta_unbounded", "double", context__.to_vec(sum(no_unbounded)));
        std::vector<double> beta_unbounded(sum(no_unbounded),double(0));
        for (int i0__ = 0U; i0__ < sum(no_unbounded); ++i0__)
            beta_unbounded[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < sum(no_unbounded); ++i0__)
            try {
            writer__.scalar_unconstrain(beta_unbounded[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_unbounded: ") + e.what());
        }

        if (!(context__.contains_r("beta_positive")))
            throw std::runtime_error("variable beta_positive missing");
        vals_r__ = context__.vals_r("beta_positive");
        pos__ = 0U;
        validate_non_negative_index("beta_positive", "sum(no_positive)", sum(no_positive));
        context__.validate_dims("initialization", "beta_positive", "double", context__.to_vec(sum(no_positive)));
        std::vector<double> beta_positive(sum(no_positive),double(0));
        for (int i0__ = 0U; i0__ < sum(no_positive); ++i0__)
            beta_positive[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < sum(no_positive); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,beta_positive[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_positive: ") + e.what());
        }

        if (!(context__.contains_r("beta_unit")))
            throw std::runtime_error("variable beta_unit missing");
        vals_r__ = context__.vals_r("beta_unit");
        pos__ = 0U;
        validate_non_negative_index("beta_unit", "sum(no_unit)", sum(no_unit));
        context__.validate_dims("initialization", "beta_unit", "double", context__.to_vec(sum(no_unit)));
        std::vector<double> beta_unit(sum(no_unit),double(0));
        for (int i0__ = 0U; i0__ < sum(no_unit); ++i0__)
            beta_unit[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < sum(no_unit); ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,beta_unit[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_unit: ") + e.what());
        }

        if (!(context__.contains_r("thetas_unbounded")))
            throw std::runtime_error("variable thetas_unbounded missing");
        vals_r__ = context__.vals_r("thetas_unbounded");
        pos__ = 0U;
        validate_non_negative_index("thetas_unbounded", "N_unbounded", N_unbounded);
        context__.validate_dims("initialization", "thetas_unbounded", "double", context__.to_vec(N_unbounded));
        std::vector<double> thetas_unbounded(N_unbounded,double(0));
        for (int i0__ = 0U; i0__ < N_unbounded; ++i0__)
            thetas_unbounded[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_unbounded; ++i0__)
            try {
            writer__.scalar_unconstrain(thetas_unbounded[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable thetas_unbounded: ") + e.what());
        }

        if (!(context__.contains_r("thetas_positive")))
            throw std::runtime_error("variable thetas_positive missing");
        vals_r__ = context__.vals_r("thetas_positive");
        pos__ = 0U;
        validate_non_negative_index("thetas_positive", "N_positive", N_positive);
        context__.validate_dims("initialization", "thetas_positive", "double", context__.to_vec(N_positive));
        std::vector<double> thetas_positive(N_positive,double(0));
        for (int i0__ = 0U; i0__ < N_positive; ++i0__)
            thetas_positive[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_positive; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,thetas_positive[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable thetas_positive: ") + e.what());
        }

        if (!(context__.contains_r("thetas_unit")))
            throw std::runtime_error("variable thetas_unit missing");
        vals_r__ = context__.vals_r("thetas_unit");
        pos__ = 0U;
        validate_non_negative_index("thetas_unit", "N_unit", N_unit);
        context__.validate_dims("initialization", "thetas_unit", "double", context__.to_vec(N_unit));
        std::vector<double> thetas_unit(N_unit,double(0));
        for (int i0__ = 0U; i0__ < N_unit; ++i0__)
            thetas_unit[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_unit; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,thetas_unit[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable thetas_unit: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            vector<T__> beta_unbounded;
            size_t dim_beta_unbounded_0__ = sum(no_unbounded);
            beta_unbounded.reserve(dim_beta_unbounded_0__);
            for (size_t k_0__ = 0; k_0__ < dim_beta_unbounded_0__; ++k_0__) {
                if (jacobian__)
                    beta_unbounded.push_back(in__.scalar_constrain(lp__));
                else
                    beta_unbounded.push_back(in__.scalar_constrain());
            }

            vector<T__> beta_positive;
            size_t dim_beta_positive_0__ = sum(no_positive);
            beta_positive.reserve(dim_beta_positive_0__);
            for (size_t k_0__ = 0; k_0__ < dim_beta_positive_0__; ++k_0__) {
                if (jacobian__)
                    beta_positive.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    beta_positive.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> beta_unit;
            size_t dim_beta_unit_0__ = sum(no_unit);
            beta_unit.reserve(dim_beta_unit_0__);
            for (size_t k_0__ = 0; k_0__ < dim_beta_unit_0__; ++k_0__) {
                if (jacobian__)
                    beta_unit.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    beta_unit.push_back(in__.scalar_lub_constrain(0,1));
            }

            vector<T__> thetas_unbounded;
            size_t dim_thetas_unbounded_0__ = N_unbounded;
            thetas_unbounded.reserve(dim_thetas_unbounded_0__);
            for (size_t k_0__ = 0; k_0__ < dim_thetas_unbounded_0__; ++k_0__) {
                if (jacobian__)
                    thetas_unbounded.push_back(in__.scalar_constrain(lp__));
                else
                    thetas_unbounded.push_back(in__.scalar_constrain());
            }

            vector<T__> thetas_positive;
            size_t dim_thetas_positive_0__ = N_positive;
            thetas_positive.reserve(dim_thetas_positive_0__);
            for (size_t k_0__ = 0; k_0__ < dim_thetas_positive_0__; ++k_0__) {
                if (jacobian__)
                    thetas_positive.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    thetas_positive.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> thetas_unit;
            size_t dim_thetas_unit_0__ = N_unit;
            thetas_unit.reserve(dim_thetas_unit_0__);
            for (size_t k_0__ = 0; k_0__ < dim_thetas_unit_0__; ++k_0__) {
                if (jacobian__)
                    thetas_unit.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    thetas_unit.push_back(in__.scalar_lub_constrain(0,1));
            }


            // transformed parameters



            // validate transformed parameters

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body
            {
            current_statement_begin__ = 736;
            validate_non_negative_index("params", "N", N);
            validate_non_negative_index("params", "Q", Q);
            vector<vector<T__> > params(N, (vector<T__>(Q)));
            stan::math::initialize(params, DUMMY_VAR__);
            stan::math::fill(params,DUMMY_VAR__);
            stan::math::assign(params,get_parameters(N,Q,P,no_unbounded,no_positive,no_unit,beta_unbounded,beta_positive,beta_unit,unbounded_indices,positive_indices,unit_indices,X,link_types, pstream__));
            current_statement_begin__ = 743;
            validate_non_negative_index("p", "N", N);
            vector<T__> p(N);
            stan::math::initialize(p, DUMMY_VAR__);
            stan::math::fill(p,DUMMY_VAR__);
            stan::math::assign(p,stan::model::rvalue(params, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(Q), stan::model::nil_index_list())), "params"));


            current_statement_begin__ = 746;
            lp_accum__.add(unbounded_lpdf<propto__>(beta_unbounded, Q, no_unbounded, unbounded_prior_types, unbounded_prior, pstream__));
            current_statement_begin__ = 747;
            lp_accum__.add(positive_lpdf<propto__>(beta_positive, Q, no_positive, positive_prior_types, positive_prior, pstream__));
            current_statement_begin__ = 748;
            lp_accum__.add(unit_lpdf<propto__>(beta_unit, Q, no_unit, unit_prior_types, unit_prior, pstream__));
            current_statement_begin__ = 751;
            if (as_bool(logical_eq(family_type,0))) {

                current_statement_begin__ = 752;
                lp_accum__.add(likelihood_lpdf<propto__>(thetas_unbounded, family, N, params, pstream__));
            } else if (as_bool(logical_eq(family_type,1))) {

                current_statement_begin__ = 754;
                lp_accum__.add(likelihood_lpdf<propto__>(thetas_positive, family, N, params, pstream__));
            } else if (as_bool(logical_eq(family_type,2))) {

                current_statement_begin__ = 756;
                lp_accum__.add(likelihood_lpdf<propto__>(thetas_unit, family, N, params, pstream__));
            }
            current_statement_begin__ = 762;
            if (as_bool(logical_eq(family_type,0))) {

                current_statement_begin__ = 763;
                lp_accum__.add(distributions_lpdf<propto__>(Z, N, thetas_unbounded, SQRT_M, lower_bounds, upper_bounds, dist_indices, p, pstream__));
            } else if (as_bool(logical_eq(family_type,1))) {

                current_statement_begin__ = 765;
                lp_accum__.add(distributions_lpdf<propto__>(Z, N, thetas_positive, SQRT_M, lower_bounds, upper_bounds, dist_indices, p, pstream__));
            } else if (as_bool(logical_eq(family_type,2))) {

                current_statement_begin__ = 767;
                lp_accum__.add(distributions_lpdf<propto__>(Z, N, thetas_unit, SQRT_M, lower_bounds, upper_bounds, dist_indices, p, pstream__));
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("beta_unbounded");
        names__.push_back("beta_positive");
        names__.push_back("beta_unit");
        names__.push_back("thetas_unbounded");
        names__.push_back("thetas_positive");
        names__.push_back("thetas_unit");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(sum(no_unbounded));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(sum(no_positive));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(sum(no_unit));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_unbounded);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_positive);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_unit);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_straussR_mixed_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector<double> beta_unbounded;
        size_t dim_beta_unbounded_0__ = sum(no_unbounded);
        for (size_t k_0__ = 0; k_0__ < dim_beta_unbounded_0__; ++k_0__) {
            beta_unbounded.push_back(in__.scalar_constrain());
        }
        vector<double> beta_positive;
        size_t dim_beta_positive_0__ = sum(no_positive);
        for (size_t k_0__ = 0; k_0__ < dim_beta_positive_0__; ++k_0__) {
            beta_positive.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> beta_unit;
        size_t dim_beta_unit_0__ = sum(no_unit);
        for (size_t k_0__ = 0; k_0__ < dim_beta_unit_0__; ++k_0__) {
            beta_unit.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector<double> thetas_unbounded;
        size_t dim_thetas_unbounded_0__ = N_unbounded;
        for (size_t k_0__ = 0; k_0__ < dim_thetas_unbounded_0__; ++k_0__) {
            thetas_unbounded.push_back(in__.scalar_constrain());
        }
        vector<double> thetas_positive;
        size_t dim_thetas_positive_0__ = N_positive;
        for (size_t k_0__ = 0; k_0__ < dim_thetas_positive_0__; ++k_0__) {
            thetas_positive.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> thetas_unit;
        size_t dim_thetas_unit_0__ = N_unit;
        for (size_t k_0__ = 0; k_0__ < dim_thetas_unit_0__; ++k_0__) {
            thetas_unit.push_back(in__.scalar_lub_constrain(0,1));
        }
            for (int k_0__ = 0; k_0__ < sum(no_unbounded); ++k_0__) {
            vars__.push_back(beta_unbounded[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < sum(no_positive); ++k_0__) {
            vars__.push_back(beta_positive[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < sum(no_unit); ++k_0__) {
            vars__.push_back(beta_unit[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N_unbounded; ++k_0__) {
            vars__.push_back(thetas_unbounded[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N_positive; ++k_0__) {
            vars__.push_back(thetas_positive[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N_unit; ++k_0__) {
            vars__.push_back(thetas_unit[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {



            // validate transformed parameters

            // write transformed parameters

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_straussR_mixed";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= sum(no_unbounded); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_unbounded" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= sum(no_positive); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_positive" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= sum(no_unit); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_unit" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_unbounded; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "thetas_unbounded" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_positive; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "thetas_positive" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_unit; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "thetas_unit" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= sum(no_unbounded); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_unbounded" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= sum(no_positive); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_positive" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= sum(no_unit); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_unit" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_unbounded; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "thetas_unbounded" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_positive; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "thetas_positive" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_unit; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "thetas_unit" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
    }

}; // model

}

typedef model_straussR_mixed_namespace::model_straussR_mixed stan_model;


#endif
